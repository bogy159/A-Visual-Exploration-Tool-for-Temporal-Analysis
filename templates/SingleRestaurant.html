<!DOCTYPE html>
<meta charset="utf-8">

<html>
   <head>
      <title>Graphs for single restaurant</title>
       <h2>Choose visualisation mode:</h2>
      <style>
         .button {
         background-color: #1c87c9;
         border: none;
         color: white;
         padding: 8px 14px;
         text-align: center;
         text-decoration: none;
         display: inline-block;
         font-size: 16px;
         margin: 4px 2px;
         cursor: pointer;
         }
      </style>
   </head>
   
   <body>
       <a href="{{ url_for('allSample') }}" class="button">All Data</a>     
       <a href="{{ url_for('singleRestaurant') }}" class="button">Single Restaurant</a> 
       <a href="{{ url_for('clustering') }}" class="button">Clustering</a>
	   <a href="{{ url_for('wordCount') }}" class="button">Word Count</a>
       <br>
       <label for="ID">ID:</label>
       <select id="selectButton"></select>
       <label for="selectGLabel">Select Graph:</label>
       <select id="selectGraphB">
          <option value="Box-plot Annual">Box-plot Annual</option>
          <option value="Box-plot Monthly">Box-plot Monthly</option>
          <option value="Violin Annual">Violin Annual</option>
          <option value="Violin Monthly">Violin Monthly</option>
		  <option value="Mixed Annual">Mixed Annual</option>
		  <option value="Matrix Annual">Matrix Annual</option>
		  <option value="Matrix Monthly">Matrix Monthly</option>
		  <option value="Continuous Line">Continuous Line Annual</option>
       </select>
       <br>
       <label for="min">Min value:</label>
       <input id="dateLow" type="date" value="2008-01-01">
       <label for="max">Max value:</label>
       <input id="dateUp" type="date" value="2017-12-31">
	   <br>
	   <label for="selectFilterM">Time of Year:</label>
       <select id="selectFilterB">
          <option value=""></option>
          <option value="0">January</option>
          <option value="1">February</option>
          <option value="2">March</option>
		  <option value="3">April</option>
		  <option value="4">May</option>
		  <option value="5">June</option>
		  <option value="6">July</option>
		  <option value="7">August</option>
		  <option value="8">September</option>
		  <option value="9">October</option>
		  <option value="10">November</option>
		  <option value="11">December</option>
		  <option value="Spring">Spring</option>
		  <option value="Summer">Summer</option>
		  <option value="Fall">Fall</option>
		  <option value="Winter">Winter</option>
       </select>
	   <label for="selectFilterD">Week Day:</label>
       <select id="selectFilDayB">
          <option value=""></option>
          <option value="1">Monday</option>
          <option value="2">Tuesday</option>
		  <option value="3">Wednesday</option>
		  <option value="4">Thursday</option>
		  <option value="5">Friday</option>
		  <option value="6">Saturday</option>
          <option value="0">Sunday</option>
       </select>
       <button onclick="updateData()">Show</button>
       <br>  
	</body>
   
</html>
    
<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<svg width="0" height="0"></svg>

<script>   
    
    // set the dimensions and margins of the graph
var margin = {top: 15, right: 30, bottom: 30, left: 40},
    width = 105 - margin.left - margin.right,
    height = 400 - margin.top - margin.bottom;    
    
//Time parse
var parseDate = d3.timeParse("%Y-%m-%d");

// append the svg object to the body of the page
var svg = d3.select("#my_dataviz")
  .append("svg")
    
// Read the data and compute summary statistics for each specie
var allData;


    d3.csv("/static/revSam.csv", function(data) {
    	
	// List of groups (here I have one group per column)
    var allGroup = d3.nest()
		.key(function(d){
			return(d.business_id)
		})
		.rollup(function(d) {
			name = d.map(function(g) { return g.name;})[0]
			postal = d.map(function(g) { return g.postal_code;})[0]
			return ({name:name, postal: postal})
		})
		.entries(data)
		
		
    // add the options to the button
    d3.select("#selectButton")
      .selectAll('myOptions')
     	.data(allGroup)
      .enter()
    	.append('option')
      .text(function (d) { return d.value.name  + " - " + d.value.postal; }) // text showed in the menu
      .attr("value", function (d) { return d.key; }) // corresponding value returned by the button
       
    allData = data;
})

function updateData() {
    
    switch (document.getElementById("selectGraphB").value) {
  case "Box-plot Annual":
    boxPlotY();
    break;
  case "Box-plot Monthly":
    boxPlotM();
    break;
  case "Violin Annual":
    violinPlotY();
    break;
  case "Violin Monthly":
    violinPlotM();
    break;
  case "Mixed Annual":
    mixPlotY();
    break;
  case "Matrix Annual":
    matrixY();
    break;
  case "Matrix Monthly":
    matrixM();
    break;
  case "Continuous Line":
    contLineY();
    break;
  default:
            
    }    
}   

function filtering(item){
	
	var result = item.filter(function(d){return d.business_id==document.getElementById("selectButton").value})
  
  if (document.getElementById("dateLow").value!="")
     {
         result = result.filter(function(d){return parseDate(d.date)>=parseDate(document.getElementById("dateLow").value)})    
     }
  if (document.getElementById("dateUp").value!="")
     {
         result = result.filter(function(d){return parseDate(d.date)<=parseDate(document.getElementById("dateUp").value)})
     }  
  if (document.getElementById("selectFilterB").value!="")
     {
		 switch (document.getElementById("selectFilterB").value) {
			  case "Spring":
				result = result.filter(function(d){return parseDate(d.date).getMonth()==2 || parseDate(d.date).getMonth()==3 || parseDate(d.date).getMonth()==4})
				break;
			  case "Summer":
				result = result.filter(function(d){return parseDate(d.date).getMonth()==5 || parseDate(d.date).getMonth()==6 || parseDate(d.date).getMonth()==7})
				break;
			  case "Fall":
				result = result.filter(function(d){return parseDate(d.date).getMonth()==8 || parseDate(d.date).getMonth()==9 || parseDate(d.date).getMonth()==10})
				break;
			  case "Winter":
				result = result.filter(function(d){return parseDate(d.date).getMonth()==11 || parseDate(d.date).getMonth()==0 || parseDate(d.date).getMonth()==1})
				break;
			  default: 
				result = result.filter(function(d){return parseDate(d.date).getMonth()==document.getElementById("selectFilterB").value})
			  }    
     }
	 if (document.getElementById("selectFilDayB").value!="")
     {
		 result = result.filter(function(d){return parseDate(d.date).getDay()==document.getElementById("selectFilDayB").value})    
     }
	 
	return result;
}
    
function boxPlotY() {
                
  var svg = d3.select("svg");
      svg.selectAll("*").remove();  
	  
  var data = filtering(allData);
    
  data.sort(function (a, b) {
    return new Date(a.date) - new Date(b.date);      
  });
        
  // Compute quartiles, median, inter quantile range min and max --> these info are then used to draw the box.
      var sumstat = d3.nest() // nest function allows to group the calculation per level of a factor
         .key(function(d) { 
             var dateObject = new Date(parseDate(d.date))
             return  dateObject.getFullYear();
         })  
        .rollup(function(d) {
          amount = d.map(function(g) { return g.stars;}).length
          mean = d3.mean(d.map(function(g) { return g.stars;}))
          q1 = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.25)      
          median = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.5)
          q3 = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.75)
          interQuantileRange = q3 - q1
          min = q1 - 1.5 * interQuantileRange
          max = q3 + 1.5 * interQuantileRange          
          //new calculation method:  
          min = d3.min(d.map(function(g) { return g.stars;}))
          max = d3.max(d.map(function(g) { return g.stars;}))
          return({q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max, amount: amount, mean: mean})
        })
        .entries(data)

  
 var svg = d3.select("#my_dataviz")
  .select("svg")
    .attr("width", width*sumstat.map((d) => d.key).length + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
  
  // Show the X scale
  var x = d3.scaleBand()
    .range([ 0, width*sumstat.map((d) => d.key).length ])
    .domain(sumstat.map((d) => d.key))
    .paddingInner(1)
    .paddingOuter(.5)
  svg.append("g")
    .data(sumstat)
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))
    .attr("font-size", "8px")
    .selectAll("text")
      .attr("transform", "translate(-10,0)rotate(-25)")
      .style("text-anchor", "end");
    

  // Show the Y scale
  var y = d3.scaleLinear()
    .domain([1,5])
    .range([height, 0])
  svg.append("g").call(d3.axisLeft(y))

  // Show the main vertical line
  svg
    .selectAll("vertLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key))})
      .attr("x2", function(d){return(x(d.key))})
      .attr("y1", function(d){return(y(d.value.min))})
      .attr("y2", function(d){return(y(d.value.max))})
      .attr("stroke", "black")
      .style("width", 40)

  // rectangle for the main box
  var boxWidth = 30
  svg
    .selectAll("boxes")
    .data(sumstat)
    .enter()
    .append("rect")
        .attr("x", function(d){return(x(d.key)-boxWidth/2)})
        .attr("y", function(d){return(y(d.value.q3))})
        .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
        .attr("width", boxWidth )
        .attr("stroke", "black")
        .style("fill", "gold")

  // Show the mean
  svg
    .selectAll("medianLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key)-boxWidth/2) })
      .attr("x2", function(d){return(x(d.key)+boxWidth/2) })
      .attr("y1", function(d){return(y(d.value.mean))})
      .attr("y2", function(d){return(y(d.value.mean))})
      .attr("stroke", "black")
      .style("width", 80)
    
//Show ratings amount    
svg
    .selectAll(".mytext")
    .data(sumstat)
    .enter()
    .append("text")
      .attr("x", function(d){return(x(d.key)-boxWidth/3) })
      .attr("y", function(d){return(y(d.value.mean)-4)})
      .text( function (d) { return d.value.amount; })
      .attr("font-family","sans-serif")
      .attr("font-size", "12px")
      .style("fill", "red")
      .append("text")    
            
    }
    
function boxPlotM() {
                
    var svg = d3.select("svg");
        svg.selectAll("*").remove();  
    
  var data = filtering(allData);
    
  data.sort(function (a, b) {
    return new Date(a.date) - new Date(b.date);      
  });
    
  // Compute quartiles, median, inter quantile range min and max --> these info are then used to draw the box.
      var sumstat = d3.nest() // nest function allows to group the calculation per level of a factor
         .key(function(d) { 
             var dateObject = new Date(parseDate(d.date))
             return  dateObject.getFullYear()+"-"+parseInt(dateObject.getMonth()+1);
         })  
        .rollup(function(d) {
          amount = d.map(function(g) { return g.stars;}).length
          mean = d3.mean(d.map(function(g) { return g.stars;}))
          q1 = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.25)      
          median = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.5)
          q3 = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.75)
          interQuantileRange = q3 - q1
          min = q1 - 1.5 * interQuantileRange
          max = q3 + 1.5 * interQuantileRange
          //new calculation method:  
          min = d3.min(d.map(function(g) { return g.stars;}))
          max = d3.max(d.map(function(g) { return g.stars;}))
          return({q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max, amount: amount, mean: mean})
        })
        .entries(data)

  
 var svg = d3.select("#my_dataviz")
  .select("svg")
    .attr("width", width*sumstat.map((d) => d.key).length + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
  
  // Show the X scale
  var x = d3.scaleBand()
    .range([ 0, width*sumstat.map((d) => d.key).length ])
    .domain(sumstat.map((d) => d.key))
    .paddingInner(1)
    .paddingOuter(.5)
  svg.append("g")
    .data(sumstat)
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))
    .attr("font-size", "8px")
    .selectAll("text")
      .attr("transform", "translate(-10,0)rotate(-25)")
      .style("text-anchor", "end");
    

  // Show the Y scale
  var y = d3.scaleLinear()
    .domain([1,5])
    .range([height, 0])
  svg.append("g").call(d3.axisLeft(y))

  // Show the main vertical line
  svg
    .selectAll("vertLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key))})
      .attr("x2", function(d){return(x(d.key))})
      .attr("y1", function(d){return(y(d.value.min))})
      .attr("y2", function(d){return(y(d.value.max))})
      .attr("stroke", "black")
      .style("width", 40)

  // rectangle for the main box
  var boxWidth = 30
  svg
    .selectAll("boxes")
    .data(sumstat)
    .enter()
    .append("rect")
        .attr("x", function(d){return(x(d.key)-boxWidth/2)})
        .attr("y", function(d){return(y(d.value.q3))})
        .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
        .attr("width", boxWidth )
        .attr("stroke", "black")
        .style("fill", "gold")

  // Show the mean
  svg
    .selectAll("medianLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key)-boxWidth/2) })
      .attr("x2", function(d){return(x(d.key)+boxWidth/2) })
      .attr("y1", function(d){return(y(d.value.mean))})
      .attr("y2", function(d){return(y(d.value.mean))})
      .attr("stroke", "black")
      .style("width", 80)
    
//Show ratings amount    
svg
    .selectAll(".mytext")
    .data(sumstat)
    .enter()
    .append("text")
      .attr("x", function(d){return(x(d.key)-boxWidth/3) })
      .attr("y", function(d){return(y(d.value.mean)-4)})
      .text( function (d) { return d.value.amount; })
      .attr("font-family","sans-serif")
      .attr("font-size", "12px")
      .style("fill", "red")
      .append("text")    
    
    }
    
function violinPlotM() {
 
  var svg = d3.select("svg");
    svg.selectAll("*").remove();  
    
  var data = filtering(allData);
    
  data.sort(function (a, b) {
    return new Date(a.date) - new Date(b.date);      
  });
    
    // Compute just the lower scale values
  var sumstat1 = d3.nest()  // nest function allows to group the calculation per level of a factor
    .key(function(d) { 
         var dateObject = new Date(parseDate(d.date))
         return  dateObject.getFullYear()+"-"+parseInt(dateObject.getMonth()+1);
    }) 
    .entries(data)
  
  // append the svg object to the body of the page
var svg = d3.select("#my_dataviz")
  .select("svg")
    .attr("width", width*sumstat1.map((d) => d.key).length + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
  
  // Build and Show the Y scale
  var y = d3.scaleLinear()
    .domain([1,5])          // Note that here the Y scale is set manually
    .range([height, 0])
  svg.append("g").call( d3.axisLeft(y).ticks(4) )

  // Build and Show the X scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis. This range has a length of x.bandwidth
  var x = d3.scaleBand()
    .range([ 0, width*sumstat1.map((d) => d.key).length ])
    .domain(sumstat1.map((d) => d.key))
    .padding(0.05)     // This is important: it is the space between 2 groups. 0 means no padding. 1 is the maximum.
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))
    .selectAll("text")
      .attr("transform", "translate(-10,0)rotate(-25)")
      .style("text-anchor", "end");	

  // Features of the histogram
  var histogram = d3.histogram()
        .domain(y.domain())
        .thresholds(y.ticks(5))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
        .value(d => d)  
  
  // Compute the binning for each group of the dataset
  var sumstat = d3.nest()  // nest function allows to group the calculation per level of a factor
    .key(function(d) { 
         var dateObject = new Date(parseDate(d.date))
         return  dateObject.getFullYear()+"-"+parseInt(dateObject.getMonth()+1);
    }) 
    .rollup(function(d) {   // For each key..
      input = d.map(function(g) { return g.stars;})    // Keep the variable called Sepal_Length
      bins = histogram(input)   // And compute the binning on it.
      return(bins)
    })
    .entries(data)
  
  //remove Unbound entires
  if (sumstat[0].key == "Unbound"){
      sumstat = sumstat.slice(1, )
      }
  if (sumstat[sumstat.length-1].key == "Unbound"){
      sumstat = sumstat.slice(0, -1)
      }

  // What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
  var maxNum = 0
  for ( i in sumstat ){
    allBins = sumstat[i].value
    lengths = allBins.map(function(a){return a.length;})
    longuest = d3.max(lengths)
    if (longuest > maxNum) { maxNum = longuest }
  }

  // The maximum width of a violin must be x.bandwidth = the width dedicated to a group
  var xNum = d3.scaleLinear()
    .range([0, x.bandwidth()])
    .domain([-maxNum,maxNum])

  // Add the shape to this svg!
  svg
    .selectAll("myViolin")
    .data(sumstat)
    .enter()        // So now we are working group per group
    .append("g")
      .attr("transform", function(d){ return("translate(" + x(d.key) +" ,0)") } ) // Translation on the right to be at the group position
    .append("path")
        .datum(function(d){ return(d.value)})     // So now we are working bin per bin
        .style("stroke", "none")
        .style("fill","blue")
        .attr("d", d3.area()
            .x0(function(d){ return(xNum(-d.length)) } )
            .x1(function(d){ return(xNum(d.length)) } )
            .y(function(d){ return(y(d.x0)) } )
            .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. Try d3.curveStep  or d3.curveCatmullRom to see the difference
            )    
    
    
 /*   //Show ratings amount    
svg
    .selectAll(".mytext")
    .data(sumstat)
    .enter()
    .append("text")
      .attr("x", function(d){return(x(d.key)-30/3) })
      .attr("y", function(d){return(y(d.value.mean)-4)})
      .text( function (d) { return d.value.amount; })
      .attr("font-family","sans-serif")
      .attr("font-size", "12px")
      .style("fill", "red")
      .append("text")    
    */
    
}
    
function violinPlotY() {
    
  var svg = d3.select("svg");
  svg.selectAll("*").remove();  
    
  var data = filtering(allData);
    
  data.sort(function (a, b) {
    return new Date(a.date) - new Date(b.date);      
  });
    
    // Compute just the lower scale values
  var sumstat1 = d3.nest()  // nest function allows to group the calculation per level of a factor
    .key(function(d) { 
         var dateObject = new Date(parseDate(d.date))
         return  dateObject.getFullYear();}) 
    .rollup(function(d) {
         mean = d3.mean(d.map(function(g) { return g.stars;})) // And compute the mean.
        return(mean)
    })
    .entries(data)
 
  // append the svg object to the body of the page
  var svg = d3.select("#my_dataviz")
    .select("svg")
      .attr("width", width*sumstat1.map((d) => d.key).length + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
  
  // Build and Show the Y scale
  var y = d3.scaleLinear()
    .domain([1,5])          // Note that here the Y scale is set manually
    .range([height, 0])
  svg.append("g").call( d3.axisLeft(y).ticks(4) )

  // Build and Show the X scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis. This range has a length of x.bandwidth
  var x = d3.scaleBand()
    .range([ 0, width*sumstat1.map((d) => d.key).length ])
    .domain(sumstat1.map((d) => d.key))
    .padding(0.05)     // This is important: it is the space between 2 groups. 0 means no padding. 1 is the maximum.
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")    
    .call(d3.axisBottom(x))
    .selectAll("text")
      .attr("transform", "translate(-10,0)rotate(-25)")
      .style("text-anchor", "end");

  // Features of the histogram
  var histogram = d3.histogram()
        .domain(y.domain())
        .thresholds(y.ticks(5))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
        .value(d => d)  
  
  // Compute the binning for each group of the dataset
  var sumstat = d3.nest()  // nest function allows to group the calculation per level of a factor
    .key(function(d) { 
         var dateObject = new Date(parseDate(d.date))
         return  dateObject.getFullYear();}) 
    .rollup(function(d) {   // For each key..
      input = d.map(function(g) { return g.stars;})    // Keep the variable called Sepal_Length
      bins = histogram(input)   // And compute the binning on it.
      //mean = d3.mean(d.map(function(g) { return g.stars;})) // And compute the mean.
      return(bins)
    })
    .entries(data)

  // What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
  var maxNum = 0
  for ( i in sumstat ){
    allBins = sumstat[i].value
    lengths = allBins.map(function(a){return a.length;})
    longuest = d3.max(lengths)
    if (longuest > maxNum) { maxNum = longuest }
  }

  // The maximum width of a violin must be x.bandwidth = the width dedicated to a group
  var xNum = d3.scaleLinear()
    .range([0, x.bandwidth()])
    .domain([-maxNum,maxNum])

  // Add the shape to this svg!
  svg
    .selectAll("myViolin")
    .data(sumstat)
    .enter()        // So now we are working group per group
    .append("g")
      .attr("transform", function(d){ return("translate(" + x(d.key) +" ,0)") } ) // Translation on the right to be at the group position
    .append("path")
        .datum(function(d){ return(d.value)})     // So now we are working bin per bin
        .style("stroke", "none")
        .style("fill","blue")
        .attr("d", d3.area()
            .x0(function(d){ return(xNum(-d.length)) } )
            .x1(function(d){ return(xNum(d.length)) } )
            .y(function(d){ return(y(d.x0)) } )
            .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. Try d3.curveStep  or d3.curveCatmullRom to see the difference
            )
    
    
}
    	
function mixPlotY() {
                
  var svg = d3.select("svg");
      svg.selectAll("*").remove();  
    
  var data = filtering(allData);
    
  data.sort(function (a, b) {
    return new Date(a.date) - new Date(b.date);      
  });
        
  // Compute quartiles, median, inter quantile range min and max --> these info are then used to draw the box.
      var sumstat = d3.nest() // nest function allows to group the calculation per level of a factor
         .key(function(d) { 
             var dateObject = new Date(parseDate(d.date))
             return  dateObject.getFullYear();
         })  
        .rollup(function(d) {
          amount = d.map(function(g) { return g.stars;}).length
          mean = d3.mean(d.map(function(g) { return g.stars;}))
          q1 = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.25)      
          median = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.5)
          q3 = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.75)
          interQuantileRange = q3 - q1
          min = q1 - 1.5 * interQuantileRange
          max = q3 + 1.5 * interQuantileRange          
          //new calculation method:  
          min = d3.min(d.map(function(g) { return g.stars;}))
          max = d3.max(d.map(function(g) { return g.stars;}))
          return({q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max, amount: amount, mean: mean})
        })
        .entries(data)

  
 var svg = d3.select("#my_dataviz")
  .select("svg")
    .attr("width", width*sumstat.map((d) => d.key).length + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
    
// Build and Show the X scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis. This range has a length of x.bandwidth
  var x = d3.scaleBand()
    .range([ 0, width*sumstat.map((d) => d.key).length ])
    .domain(sumstat.map((d) => d.key))
	.paddingInner(1)
    .paddingOuter(0.5)
    .padding(0.05)     // This is important: it is the space between 2 groups. 0 means no padding. 1 is the maximum.
  svg.append("g")
    .data(sumstat)
    .attr("transform", "translate(0," + height + ")")    
    .call(d3.axisBottom(x))
    .selectAll("text")
      .attr("transform", "translate(-10,0)rotate(-25)")
      .style("text-anchor", "end");


  // Show the Y scale
  var y = d3.scaleLinear()
    .domain([1,5])
    .range([height, 0])
  svg.append("g").call(d3.axisLeft(y))

  var boxWidth = 30

  // Show the main vertical line
  svg
    .selectAll("vertLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key)+boxWidth/2)})
      .attr("x2", function(d){return(x(d.key)+boxWidth/2)})
      .attr("y1", function(d){return(y(d.value.min))})
      .attr("y2", function(d){return(y(d.value.max))})
      .attr("stroke", "black")
      .style("width", 40)

  // rectangle for the main box  
  svg
    .selectAll("boxes")
    .data(sumstat)
    .enter()
    .append("rect")
        .attr("x", function(d){return(x(d.key))})
        .attr("y", function(d){return(y(d.value.q3))})
        .attr("height", function(d){return(y(d.value.q1)-y(d.value.q3))})
        .attr("width", boxWidth )
        .attr("stroke", "black")
        .style("fill", "gold")
		//.style("fill-opacity", 0.7)

  // Show the mean
  svg
    .selectAll("medianLines")
    .data(sumstat)
    .enter()
    .append("line")
      .attr("x1", function(d){return(x(d.key)) })
      .attr("x2", function(d){return(x(d.key)+boxWidth) })
      .attr("y1", function(d){return(y(d.value.mean))})
      .attr("y2", function(d){return(y(d.value.mean))})
      .attr("stroke", "black")
      .style("width", 80)
    
//Show ratings amount    
svg
    .selectAll(".mytext")
    .data(sumstat)
    .enter()
    .append("text")
      .attr("x", function(d){return(x(d.key)+boxWidth/4) })
      .attr("y", function(d){return(y(d.value.mean)-4)})
      .text( function (d) { return d.value.amount; })
      .attr("font-family","sans-serif")
      .attr("font-size", "12px")
      .style("fill", "black")
      .append("text")    
    
	
	
	// append the svg object to the body of the page
  svg
    .select("svg")
      .attr("width", width*sumstat.map((d) => d.key).length + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
	
	// Features of the histogram
  var histogram = d3.histogram()
        .domain(y.domain())
        .thresholds(y.ticks(5))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
        .value(d => d)  
  
  // Compute the binning for each group of the dataset
  var sumstat2 = d3.nest()  // nest function allows to group the calculation per level of a factor
    .key(function(d) { 
         var dateObject = new Date(parseDate(d.date))
         return  dateObject.getFullYear();}) 
    .rollup(function(d) {   // For each key..
      input = d.map(function(g) { return g.stars;})    // Keep the variable called Sepal_Length
      bins = histogram(input)   // And compute the binning on it.
      //mean = d3.mean(d.map(function(g) { return g.stars;})) // And compute the mean.
      return(bins)
    })
    .entries(data)

  // What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
  var maxNum = 0
  for ( i in sumstat2 ){
    allBins = sumstat2[i].value
    lengths = allBins.map(function(a){return a.length;})
    longuest = d3.max(lengths)
    if (longuest > maxNum) { maxNum = longuest }
  }

  // The maximum width of a violin must be x.bandwidth = the width dedicated to a group
  var xNum = d3.scaleLinear()
    .range([0, x.bandwidth()])
    .domain([-maxNum,maxNum])

  // Add the shape to this svg!
  svg
    .selectAll("myViolin")
    .data(sumstat2)
    .enter()        // So now we are working group per group
    .append("g")
      .attr("transform", function(d){ return("translate(" + x(d.key) +" ,0)") } ) // Translation on the right to be at the group position
    .append("path")
        .datum(function(d){ return(d.value)})     // So now we are working bin per bin
        .style("stroke", "blue")
        .style("fill","green")
		.style("fill-opacity", 0.3)
        .attr("d", d3.area()
            .x0(function(d){ return(xNum(-d.length)) } )
            .x1(function(d){ return(xNum(d.length)) } )
            .y(function(d){ return(y(d.x0)) } )
            .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. Try d3.curveStep  or d3.curveCatmullRom to see the difference
            )
    }
   
function matrixY(){
	
var svg = d3.select("svg");
      svg.selectAll("*").remove();  
	  
  var largestQuadrant = 2; //This is for the colour domain
	  
  var data = filtering(allData);
    
  data.sort(function (a, b) {
    return new Date(a.date) - new Date(b.date);      
  });
        
  // Compute just the lower scale values
  var sumstat = d3.nest()  // nest function allows to group the calculation per level of a factor
    .key(function(d) { 
         var dateObject = new Date(parseDate(d.date))
         return  dateObject.getFullYear();}) 	
    .entries(data)
  
 var svg = d3.select("#my_dataviz")
  .select("svg")
    .attr("width", width*sumstat.map((d) => d.key).length + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
  
  // Show the X scale
  var x = d3.scaleBand()
    .range([ 0, width*sumstat.map((d) => d.key).length ])
    .domain(sumstat.map((d) => d.key))
    .padding(0.01);
  svg.append("g")
    .data(sumstat)
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))
    .attr("font-size", "8px")
    .selectAll("text")
      .attr("transform", "translate(-10,0)rotate(-25)")
      .style("text-anchor", "end");
    
  // Show the Y scale
  var y = d3.scaleBand()
    .domain([1,2,3,4,5])
    .range([height, 0])
	.padding(0.01);
  svg.append("g")
    .call(d3.axisLeft(y))

	
	  
	  // Compute just the lower scale values
  var sumstat2 = d3.nest()  // nest function allows to group the calculation per level of a factor
    .key(function(d) { 
         var dateObject = new Date(parseDate(d.date))
		 var star = d.stars
         return  dateObject.getFullYear() +"_"+ star;}) 
	.rollup(function(d) {   // For each key..
		 amount = d.map(function(g) { return g.stars;}).length
		 var datichka = new Date(parseDate(d.map(function(g) { return g.date;})[0]))
		 date = datichka.getFullYear()
		 star = d.map(function(g) { return g.stars;})[0]
		 if (largestQuadrant<amount){		//This is for assigning the colour domain	 
		 largestQuadrant = amount
		 }
         return({amount:amount,date:date,star:star})
    })
    .entries(data)
	  
	// Build color scale
	var myColor = d3.scaleLinear()
	  .range(['#fef0d9','#fdcc8a','#fc8d59','#d7301f'])
	  .domain([1,largestQuadrant*0.33,largestQuadrant*0.67,largestQuadrant])
	  
  svg.selectAll()
  .data(sumstat2, function(d) {return d.key;})
  .enter()
  .append("rect") 
	.attr("x", function(d) { return x(d.value.date) })
	.attr("y", function(d) { return y(d.value.star) })
	.attr("width", x.bandwidth() )
	.attr("height", y.bandwidth() )
	.style("fill", function(d) { return myColor(d.value.amount)} )
  
  // Handmade legend
	svg.append("circle").attr("cx",width-20).attr("cy",height-55).attr("r", 5).style("fill", "#fef0d9").style("stroke", "black")
	svg.append("circle").attr("cx",width-20).attr("cy",height-40).attr("r", 5).style("fill", "#fdcc8a").style("stroke", "black")
	svg.append("circle").attr("cx",width-20).attr("cy",height-25).attr("r", 5).style("fill", "#fc8d59").style("stroke", "black")
	svg.append("circle").attr("cx",width-20).attr("cy",height-10).attr("r", 5).style("fill", "#d7301f").style("stroke", "black")
	svg.append("text").attr("x", width-12).attr("y", height-54).text("1 review").style("font-size", "12px").attr("alignment-baseline","middle")
	svg.append("text").attr("x", width-12).attr("y", height-39).text("Around " + parseInt(largestQuadrant*0.33) + " reviews").style("font-size", "12px").attr("alignment-baseline","middle")
	svg.append("text").attr("x", width-12).attr("y", height-24).text("Around " + parseInt(largestQuadrant*0.67) + " reviews").style("font-size", "12px").attr("alignment-baseline","middle")
	svg.append("text").attr("x", width-12).attr("y", height-9).text(largestQuadrant + " reviews").style("font-size", "12px").attr("alignment-baseline","middle")
    
}	

function matrixM(){
	
var svg = d3.select("svg");
      svg.selectAll("*").remove();  
	  
  var largestQuadrant = 2; //This is for the colour domain
	  
  var data = filtering(allData);
    
  data.sort(function (a, b) {
    return new Date(a.date) - new Date(b.date);      
  });
        
  // Compute just the lower scale values
  var sumstat = d3.nest()  // nest function allows to group the calculation per level of a factor
    .key(function(d) { 
         var dateObject = new Date(parseDate(d.date))
         return  dateObject.getFullYear()+"-"+parseInt(dateObject.getMonth()+1);}) 	
    .entries(data)
  
 var svg = d3.select("#my_dataviz")
  .select("svg")
    .attr("width", (width-10)*sumstat.map((d) => d.key).length + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
  
  // Show the X scale
  var x = d3.scaleBand()
    .range([ 0, (width-20)*sumstat.map((d) => d.key).length ])
    .domain(sumstat.map((d) => d.key))
    .padding(0.01);
  svg.append("g")
    .data(sumstat)
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))
    .attr("font-size", "8px")
    .selectAll("text")
      .attr("transform", "translate(-10,0)rotate(-30)")
      .style("text-anchor", "end");
    
  // Show the Y scale
  var y = d3.scaleBand()
    .domain([1,2,3,4,5])
    .range([height, 0])
	.padding(0.01);
  svg.append("g")
    .call(d3.axisLeft(y))

	
	  
	  // Compute just the lower scale values
  var sumstat2 = d3.nest()  // nest function allows to group the calculation per level of a factor
    .key(function(d) { 
         var dateObject = new Date(parseDate(d.date))
		 var star = d.stars
         return  dateObject.getFullYear()+"-"+parseInt(dateObject.getMonth()+1) +"_"+ star;}) 
	.rollup(function(d) {   // For each key..
		 amount = d.map(function(g) { return g.stars;}).length
		 var datichka = new Date(parseDate(d.map(function(g) { return g.date;})[0]))
		 date = datichka.getFullYear() +"-"+parseInt(datichka.getMonth()+1);
		 star = d.map(function(g) { return g.stars;})[0]
		 if (largestQuadrant<amount){		//This is for assigning the colour domain	 
		 largestQuadrant = amount
		 }
         return({amount:amount,date:date,star:star})
    })
    .entries(data)
	  
	// Build color scale
	var myColor = d3.scaleLinear()
	  .range(['#fef0d9','#fdcc8a','#fc8d59','#d7301f'])
	  .domain([1,largestQuadrant*0.33,largestQuadrant*0.67,largestQuadrant])
	  
  svg.selectAll()
  .data(sumstat2, function(d) {return d.key;})
  .enter()
  .append("rect") 
	.attr("x", function(d) { return x(d.value.date) })
	.attr("y", function(d) { return y(d.value.star) })
	.attr("width", x.bandwidth() )
	.attr("height", y.bandwidth() )
	.style("fill", function(d) { return myColor(d.value.amount)} )
  
  // Handmade legend
	svg.append("circle").attr("cx",width-20).attr("cy",height-55).attr("r", 5).style("fill", "#fef0d9").style("stroke", "black")
	svg.append("circle").attr("cx",width-20).attr("cy",height-40).attr("r", 5).style("fill", "#fdcc8a").style("stroke", "black")
	svg.append("circle").attr("cx",width-20).attr("cy",height-25).attr("r", 5).style("fill", "#fc8d59").style("stroke", "black")
	svg.append("circle").attr("cx",width-20).attr("cy",height-10).attr("r", 5).style("fill", "#d7301f").style("stroke", "black")
	svg.append("text").attr("x", width-12).attr("y", height-54).text("1 review").style("font-size", "12px").attr("alignment-baseline","middle")
	svg.append("text").attr("x", width-12).attr("y", height-39).text("Around " + parseInt(largestQuadrant*0.33) + " reviews").style("font-size", "12px").attr("alignment-baseline","middle")
	svg.append("text").attr("x", width-12).attr("y", height-24).text("Around " + parseInt(largestQuadrant*0.67) + " reviews").style("font-size", "12px").attr("alignment-baseline","middle")
	svg.append("text").attr("x", width-12).attr("y", height-9).text(largestQuadrant + " reviews").style("font-size", "12px").attr("alignment-baseline","middle")
    
}	

function contLineY(){
	
  var svg = d3.select("svg");
	svg.selectAll("*").remove();  
	  
  var data = filtering(allData);
    
  data.sort(function (a, b) {
    return new Date(a.date) - new Date(b.date);      
  });
        
  // Compute quartiles, median, inter quantile range min and max --> these info are then used to draw the box.
      var sumstat = d3.nest() // nest function allows to group the calculation per level of a factor
         .key(function(d) { 
             var dateObject = new Date(parseDate(d.date))
             return  dateObject.getFullYear();
         })  
        .rollup(function(d) {
          amount = d.map(function(g) { return g.stars;}).length
          mean = d3.mean(d.map(function(g) { return g.stars;}))
          q1 = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.25)      
          median = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.5)
          q3 = d3.quantile(d.map(function(g) { return g.stars;}).sort(d3.ascending),.75)
          interQuantileRange = q3 - q1
          min = q1 - 1.5 * interQuantileRange
          max = q3 + 1.5 * interQuantileRange          
          //new calculation method:  
          //min = d3.min(d.map(function(g) { return g.stars;}))
          //max = d3.max(d.map(function(g) { return g.stars;}))
		  //new Quantile method:  
          min = q1
          max = q3
          return({q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max, amount: amount, mean: mean})
        })
        .entries(data)

  
 var svg = d3.select("#my_dataviz")
  .select("svg")
    .attr("width", width*sumstat.map((d) => d.key).length + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");
  
  // Show the X scale
  var x = d3.scaleBand()
    .range([ 0, width*sumstat.map((d) => d.key).length ])
    .domain(sumstat.map((d) => d.key))
    .paddingInner(1)
    .paddingOuter(.5)
  svg.append("g")
    .data(sumstat)
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x))
    .attr("font-size", "8px")
    .selectAll("text")
      .attr("transform", "translate(-10,0)rotate(-25)")
      .style("text-anchor", "end");
    

  // Show the Y scale
  var y = d3.scaleLinear()
    .domain([1,5])
    .range([height, 0])
  svg.append("g").call(d3.axisLeft(y))
	  
	  // Show confidence interval
    svg
	  .append("path")
      .datum(sumstat)
      .attr("fill", "#cce5df")
      .attr("stroke", "none")
      .attr("d", d3.area()
        .x(function(d) { return x(d.key) })
        .y0(function(d) { return y(d.value.max) })
        .y1(function(d) { return y(d.value.min) })
        )

    // Add the mean line
    svg
      .append("path")
      .datum(sumstat)
      .attr("fill", "none")
      .attr("stroke", "blue")
      .attr("stroke-width", 1.5)
      .attr("d", d3.line()
        .x(function(d) { return x(d.key) })
        .y(function(d) { return y(d.value.mean) })
        )
		
		// Add the median line
    svg
      .append("path")
      .datum(sumstat)
      .attr("fill", "none")
      .attr("stroke", "green")
      .attr("stroke-width", 1.5)
      .attr("d", d3.line()
        .x(function(d) { return x(d.key) })
        .y(function(d) { return y(d.value.median) })
        )
	
	// Handmade legend
	svg.append("circle").attr("cx",width-20).attr("cy",height-25).attr("r", 5).style("fill", "blue").style("stroke", "black")
	svg.append("circle").attr("cx",width-20).attr("cy",height-10).attr("r", 5).style("fill", "green").style("stroke", "black")
	svg.append("text").attr("x", width-12).attr("y", height-24).text("Mean").style("font-size", "12px").attr("alignment-baseline","middle")
	svg.append("text").attr("x", width-12).attr("y", height-9).text("Median").style("font-size", "12px").attr("alignment-baseline","middle")

	
}

</script>
